{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AES-Kotlin","text":"<p>A pure Kotlin implementation of the AES block cipher algorithm and all common modes of operation (CBC, CFB, CTR, ECB, and OFB).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Pure Kotlin (with no dependencies, or optional BouncyCastle for advanced use cases)</li> <li>Supports all key sizes (128-bit, 192-bit, and 256-bit)</li> <li>Supports all common modes of operation (CBC, CFB, CTR, ECB, and OFB)</li> <li>Works on the JVM and Android</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#gradle-kotlin-dsl","title":"Gradle (Kotlin DSL)","text":"<p>Add the following to your <code>build.gradle.kts</code> file:</p> <pre><code>dependencies {\n    implementation(\"io.github.niyajali:aes-kotlin:1.0.0\")\n}\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#keys","title":"Keys","text":"<p>All keys must be 128 bits (16 bytes), 192 bits (24 bytes), or 256 bits (32 bytes) long. You can generate keys from passwords using a key derivation function like PBKDF2.</p> <pre><code>import javax.crypto.spec.SecretKeySpec\nimport javax.crypto.SecretKeyFactory\nimport javax.crypto.spec.PBEKeySpec\n\n// Generate a 256-bit key from a password\nval password = \"myPassword\".toCharArray()\nval salt = \"mySalt\".toByteArray()\nval factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\")\nval spec = PBEKeySpec(password, salt, 65536, 256)\nval key = factory.generateSecret(spec).encoded\nval secretKey = SecretKeySpec(key, \"AES\")\n</code></pre>"},{"location":"#common-modes-of-operation","title":"Common Modes of Operation","text":""},{"location":"#ctr-counter-recommended","title":"CTR - Counter (Recommended)","text":"<pre><code>import javax.crypto.Cipher\nimport javax.crypto.spec.IvParameterSpec\n\nval key = \"0123456789abcdef\".toByteArray() // 128-bit key\nval iv = \"1234567890abcdef\".toByteArray() // 16-byte initialization vector\n\nval cipher = Cipher.getInstance(\"AES/CTR/NoPadding\")\ncipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key, \"AES\"), IvParameterSpec(iv))\n\nval plaintext = \"Hello, Kotlin AES!\".toByteArray()\nval encrypted = cipher.doFinal(plaintext)\n\nprintln(\"Encrypted: ${encrypted.joinToString(\"\") { \"%02x\".format(it) }}\")\n\n// Decrypt\ncipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(key, \"AES\"), IvParameterSpec(iv))\nval decrypted = cipher.doFinal(encrypted)\nprintln(\"Decrypted: ${String(decrypted)}\")\n</code></pre>"},{"location":"#cbc-cipher-block-chaining-recommended","title":"CBC - Cipher-Block Chaining (Recommended)","text":"<pre><code>val key = \"0123456789abcdef\".toByteArray() // 128-bit key\nval iv = \"1234567890abcdef\".toByteArray() // 16-byte initialization vector\n\nval cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\ncipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key, \"AES\"), IvParameterSpec(iv))\n\nval plaintext = \"Hello, Kotlin AES!\".toByteArray()\nval encrypted = cipher.doFinal(plaintext)\n\nprintln(\"Encrypted: ${encrypted.joinToString(\"\") { \"%02x\".format(it) }}\")\n\n// Decrypt\ncipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(key, \"AES\"), IvParameterSpec(iv))\nval decrypted = cipher.doFinal(encrypted)\nprintln(\"Decrypted: ${String(decrypted)}\")\n</code></pre>"},{"location":"#cfb-cipher-feedback","title":"CFB - Cipher Feedback","text":"<pre><code>val key = \"0123456789abcdef\".toByteArray() // 128-bit key\nval iv = \"1234567890abcdef\".toByteArray() // 16-byte initialization vector\n\nval cipher = Cipher.getInstance(\"AES/CFB/NoPadding\")\ncipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key, \"AES\"), IvParameterSpec(iv))\n\nval plaintext = \"Hello, Kotlin AES!\".toByteArray()\nval encrypted = cipher.doFinal(plaintext)\n\nprintln(\"Encrypted: ${encrypted.joinToString(\"\") { \"%02x\".format(it) }}\")\n\n// Decrypt\ncipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(key, \"AES\"), IvParameterSpec(iv))\nval decrypted = cipher.doFinal(encrypted)\nprintln(\"Decrypted: ${String(decrypted)}\")\n</code></pre>"},{"location":"#ofb-output-feedback","title":"OFB - Output Feedback","text":"<pre><code>val key = \"0123456789abcdef\".toByteArray() // 128-bit key\nval iv = \"1234567890abcdef\".toByteArray() // 16-byte initialization vector\n\nval cipher = Cipher.getInstance(\"AES/OFB/NoPadding\")\ncipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key, \"AES\"), IvParameterSpec(iv))\n\nval plaintext = \"Hello, Kotlin AES!\".toByteArray()\nval encrypted = cipher.doFinal(plaintext)\n\nprintln(\"Encrypted: ${encrypted.joinToString(\"\") { \"%02x\".format(it) }}\")\n\n// Decrypt\ncipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(key, \"AES\"), IvParameterSpec(iv))\nval decrypted = cipher.doFinal(encrypted)\nprintln(\"Decrypted: ${String(decrypted)}\")\n</code></pre>"},{"location":"#ecb-electronic-codebook-not-recommended","title":"ECB - Electronic Codebook (NOT Recommended)","text":"<pre><code>val key = \"0123456789abcdef\".toByteArray() // 128-bit key\n\nval cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\")\ncipher.init(Cipher.ENCRYPT_MODE, SecretKeySpec(key, \"AES\"))\n\nval plaintext = \"Hello, Kotlin AES!\".toByteArray()\nval encrypted = cipher.doFinal(plaintext)\n\nprintln(\"Encrypted: ${encrypted.joinToString(\"\") { \"%02x\".format(it) }}\")\n\n// Decrypt\ncipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(key, \"AES\"))\nval decrypted = cipher.doFinal(encrypted)\nprintln(\"Decrypted: ${String(decrypted)}\")\n</code></pre>"},{"location":"#block-cipher-direct-usage","title":"Block Cipher (Direct Usage)","text":"<p>If you need to use the block cipher directly (e.g., for custom modes of operation), you can use the following:</p> <pre><code>import javax.crypto.Cipher\n\nval key = \"0123456789abcdef\".toByteArray() // 128-bit key\nval secretKey = SecretKeySpec(key, \"AES\")\n\nval cipher = Cipher.getInstance(\"AES\")\ncipher.init(Cipher.ENCRYPT_MODE, secretKey)\n\nval plaintext = \"ABlockIs16Bytes!\".toByteArray()\nval encrypted = cipher.doFinal(plaintext)\n\nprintln(\"Encrypted: ${encrypted.joinToString(\"\") { \"%02x\".format(it) }}\")\n\n// Decrypt\ncipher.init(Cipher.DECRYPT_MODE, secretKey)\nval decrypted = cipher.doFinal(encrypted)\nprintln(\"Decrypted: ${String(decrypted)}\")\n</code></pre>"},{"location":"#notes","title":"Notes","text":""},{"location":"#what-is-a-key","title":"What is a Key?","text":"<p>A key is essentially a \u201cpassword\u201d for encryption. However, AES requires the key to be a specific length: 128 bits (16 bytes), 192 bits (24 bytes), or 256 bits (32 bytes). If you have a password of arbitrary length, you should use a Password-Based Key Derivation Function (PBKDF) like PBKDF2 to generate a key of the correct length.</p> <p>Example:</p> <pre><code>import javax.crypto.SecretKeyFactory\nimport javax.crypto.spec.PBEKeySpec\n\nval password = \"myPassword\".toCharArray()\nval salt = \"mySalt\".toByteArray()\nval factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\")\nval spec = PBEKeySpec(password, salt, 65536, 256) // 256-bit key\nval key = factory.generateSecret(spec).encoded\n</code></pre>"},{"location":"#performance","title":"Performance","text":"<p>For most use cases, the built-in <code>javax.crypto</code> implementation is sufficient and highly optimized. If you need additional performance or features, consider using BouncyCastle.</p>"},{"location":"#testing","title":"Testing","text":"<p>To test your implementation, you can use known test vectors from sources like NIST.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"releasing/","title":"Releasing","text":"<ol> <li>Change the version in <code>gradle.properties</code> to a non-SNAPSHOT version.</li> <li><code>git commit -am \"Prepare for release X.Y.Z.\"</code> (where X.Y.Z is the new version)</li> <li><code>git tag -a X.Y.Z -m \"Version X.Y.Z\"</code> (where X.Y.Z is the new version).</li> <li>Update <code>gradle.properties</code> to the next SNAPSHOT version.</li> <li><code>git commit -am \"Prepare next development version.\"</code>.</li> <li><code>git push &amp;&amp; git push --tags</code>.</li> </ol> <p>This will trigger a GitHub Action workflow which will create a GitHub release and upload the release artifacts to Maven Central.</p> <p>```</p>"}]}